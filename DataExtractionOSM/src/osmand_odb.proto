// Highly coupled with protobuf 2.3.0
option java_package = "net.osmand.binary";
//protoc --java_out=DataExtractionOSM/src DataExtractionOSM/src/osmand_odb.proto

// C++ # cd OsmAnd
// # protoc --proto_path=../DataExtractionOSM/src --cpp_out=jni/osmand/proto ../DataExtractionOSM/src/osmand_odb.proto

//
//  STORAGE LAYER: Storing primitives.
//

// IMPORTANT :  These messages are not intented to be parsed by google engine (because of the random access to the file)
// The main difference that size of that messages is not var int and is always fixed int size
message OsmAndStructure {
   required uint32 version = 1;

   // System.currentTimeMillis()
   required int64 dateCreated = 18;

   // first version of map index was 3.
   // encoded as fixed32 length delimited  
   repeated OsmAndAddressIndex addressIndex = 7;
   
    // encoded as fixed32 length delimited  
   repeated OsmAndTransportIndex transportIndex = 4;
   
   // slight changes previous version was 5
   // encoded as fixed32 length delimited
   repeated OsmAndPoiIndex poiIndex = 8;
   
    // first version of map index was 2.
   // encoded as fixed32 length delimited
   repeated OsmAndMapIndex mapIndex = 6;
   
   // encoded as fixed32 length delimited
   repeated OsmAndRoutingIndex routingIndex = 9;

   // last field should version again (to check consistency)
   required uint32 versionConfirm = 32;
}

message OsmAndTileBox {
    // everything is encoded as 31 tile zoom
    required uint32 left = 1;
    required uint32 right = 2;
    required uint32 top = 3;
    required uint32 bottom = 4;
}

/** 
  String table, contains the common strings in each block.
 */
message StringTable {
   repeated string s = 1;
}

message IndexedStringTable {
   // common prefix for all strings inside
   optional string prefix = 1;
   
   // key, val and subtables are mixed and order is preserved by key (ascending)
   // so that's example of data : key1,val1,subtables1,key2,val2,key3,val3,subtables3,subtables3
   repeated string key = 3;
   // the shift to the data or one uint data itself
   repeated fixed32 val = 4;
   // subtables are supposed to make search faster instead of searching through all strings 
   // it's enough to read prefix in the header
   repeated IndexedStringTable subtables = 5;
}


///////////////////////
////  Map messages ////
///////////////////////
message OsmAndMapIndex {

	required string name = 2;

	repeated MapEncodingRule rules = 4;
	message MapEncodingRule {
		required string tag = 3;
		optional string value = 5;
		// it is optional because natural order in block of rules
		// is the same as id (id is 1-based and order)
		optional uint32 id = 7;
		// min zoom combination exists
		optional uint32 minZoom = 9;
		// "additional" flag is encoded as %2 == 1
		optional uint32 type = 10;
	}

	// encoded as fixed32 length delimited
	repeated MapRootLevel levels = 5;
	message MapRootLevel {
		required int32 maxZoom = 1;
		required int32 minZoom = 2;
		required int32 left = 3;
		required int32 right = 4;
		required int32 top = 5;
		required int32 bottom = 6;

		repeated MapDataBox boxes = 7;

		repeated MapDataBlock blocks = 15;
	}

	message MapDataBox {
		required sint32 left = 1; // delta encoded
		required sint32 right = 2; // delta encoded
		required sint32 top = 3; // delta encoded
		required sint32 bottom = 4; // delta encoded

		//shift from mapdatabox start to message MapDataBlock
		optional fixed32 shiftToMapData = 5;
		// true (byte = 1) - full ocean, false (byte = 0) - full land
		optional bool ocean = 6;

		repeated MapDataBox boxes = 7;
	}
}

message MapDataBlock {
	// coordinates can take much space 4*4*count of data blocks=
//   required sint32 left = 1; // delta encoded
//   required sint32 right = 2; // delta encoded
//   required sint32 top = 3; // delta encoded
//   required sint32 bottom = 4; // delta encoded
   
   optional uint64 baseId = 10;

   // in future here can be optional raster tile
   repeated MapData dataObjects = 12;

   optional StringTable stringTable = 15;


}


message MapData {
  // array of delta x,y sint32 (CodedIinputStream) >> 5
  // first x delta to Tree.left, y to delta Tree.top (next delta to previous)
  // point, line or outer polygon coordinates
  optional bytes coordinates = 1;
  optional bytes areaCoordinates = 2;
  repeated bytes polygonInnerCoordinates = 4;

  // array of raw var int types
  optional bytes additionalTypes = 6;
  // array of raw var int types
  required bytes types = 7;

  // repeated array<pair<tagId : raw_var_int, indexOfStringInParent : raw_var_int> >
  optional bytes stringNames = 10; // in parent block

  required sint64 id = 12; // delta encoded

  optional bytes rasterBytes = 15;

}



////////////////////////////
/////  Address messages ////
////////////////////////////

message OsmAndAddressIndex {
	
	required string name = 1;
	optional string name_en = 2;
	
	optional OsmAndTileBox boundaries = 3;
	
	
	// encoded as fixed32 length delimited
	// 1) cities and towns - type 1,  2) postcodes - type 2, 3) villages - type 3
	repeated CitiesIndex cities = 6;
	message CitiesIndex {
	    // cities and towns - type 1,  postcodes - type 2, villages - type 3
    	required uint32 type = 2;

    	// not mixed
	    // the list of the cities and the blocks are synchronized by the order (so even empty block will be written)
	    repeated CityIndex cities = 5;

    	repeated CityBlockIndex blocks = 7;
	}

	// encoded as fixed32 length delimited
	optional OsmAndAddressNameIndexData nameIndex = 7;  
}

message OsmAndAddressNameIndexData {
    // shift to AddressNameIndexData starting from first OsmAndAddressNameIndexData message
    // encoded as fixed32 length delimited
    required IndexedStringTable table = 4;

    repeated AddressNameIndexData atom = 7;
   	message AddressNameIndexData {
   		// shift is measured from start (before length)
   		repeated AddressNameIndexDataAtom atom = 4;
	}
}



message AddressNameIndexDataAtom {
     optional string name = 1;
     optional string nameEn = 2;
     // 1 - city, 2 - postcode, 3 - village,  4 - street
     required uint32 type = 3; 

     // mixed 
     // shift from start AddressNameIndexData (!) to ...Index
     repeated int32 shiftToIndex = 5;
     // optional used in case of type=street
     repeated int32 shiftToCityIndex = 6;
}


message CityIndex {
	// should be written the first (for city), for postcode is optional
    optional uint32 city_type = 1; // 0-5 enum CityType
    
	required string name = 2;
	optional string name_en = 3;
	optional uint64 id = 4;
	
	required uint32 x = 5; // x tile of 31 zoom
	required uint32 y = 6; // y tile of 31 zoom
	
	// shift from start CityIndex (without length) to cityBlockIndex
	optional fixed32 shiftToCityBlockIndex = 10;
}

message CityBlockIndex {

    // shift from start cityBlockIndex to CityIndex 
	optional fixed32 shiftToCityIndex = 4;

	// buildings that doesn't belong to the street
	repeated BuildingIndex buildings = 10;
	
	repeated StreetIndex streets = 12;
}

message StreetIndex {
	required string name = 1;
	optional string name_en = 2;
	
	required sint32 x = 3; // delta encoded to parent 24 zoom
	required sint32 y = 4; // delta encoded to parent 24 zoom
	
	optional uint64 id = 6;
	
	repeated BuildingIndex buildings = 12;
	
	repeated StreetIntersection intersections = 5;
}

message StreetIntersection {
	required string name = 2;
	optional string name_en = 3;
	
	required sint32 intersectedX = 4; // delta encoded to parent street x 24 zoom
	required sint32 intersectedY = 5; // delta encoded to parent street y 24 zoom
} 

message BuildingIndex {
	required string name = 1;
	optional string name_en = 2;
	
	// used for interpolation
	optional string name2 = 3;
	optional string name_en2 = 4;
	
	// special values 0 means - nothing, -1 - all, -2 - even, -3 - odd, -4, alphabetic
	// positive - just positive interpolation 
	optional sint32 interpolation = 5;
	
	required sint32 x = 7; // delta encoded to parent 24 zoom
	required sint32 y = 8; // delta encoded to parent 24 zoom
	
	// used for interpolation
	optional sint32 x2 = 9; // delta encoded to parent 24 zoom
	optional sint32 y2 = 10; // delta encoded to parent 24 zoom
	
	optional uint64 id = 13;
	optional string postcode = 14;
}

////////////////////////////
//// Transport messages ////
////////////////////////////

message TransportRoutes {
   repeated TransportRoute routes = 6; 
}

message TransportRoute {
   required uint64 id = 1;
   
   optional uint32 type = 3; // reference in string table
   optional uint32 operator = 4; // reference in string table
   optional string ref = 5;
   optional uint32 name = 6; // reference in string table
   optional uint32 name_en = 7; // reference in string table
   optional uint32 distance = 8; // distance in meters
   
   repeated TransportRouteStop directStops = 15;
   repeated TransportRouteStop reverseStops = 16; 
}

message TransportRouteStop {
   required sint64 id = 1; // delta encoded to previous stop (first stop is delta to 0)
   required sint32 dx = 2; // delta encoded to previous stop (24 zoom)
   required sint32 dy = 3; // delta encoded to previous stop (24 zoom)
   
   required uint32 name = 6; // index in message table
   optional uint32 name_en = 7; // index in message table
}

message TransportStop {
   required sint32 dx = 1; // delta encoded to parent (24 zoom) to left
   required sint32 dy = 2; // delta encoded to parent (24 zoom) to top

   required sint64 id = 5; // delta encoded to parent base id 
   
   required uint32 name = 6; // index in message table
   optional uint32 name_en = 7; // index in message table
   
   repeated uint32 routes = 16; // -shift to transport route containing that stop 
   								// TransportStop.Message.start -  sizeof(TransportStop.Message.length) - routes[i] 
   								//				= TransportRoute.Message.start - sizeof(TransportRoute.Message.length)
   								// message is started when body is started 
 
}

message TransportStopsTree {
   required sint32 left = 1; // delta encoded (24 zoom)
   required sint32 right = 2; // delta encoded (24 zoom)
   required sint32 top = 3; // delta encoded (24 zoom)
   required sint32 bottom = 4; // delta encoded (24 zoom)
   
   // encoded as fixed32 length delimited
   repeated TransportStopsTree subtrees = 7;
   
   repeated TransportStop leafs = 8;
   
   // written as last
   optional uint64 baseId = 16;
}
			
message OsmAndTransportIndex {
    optional string name = 1;
    	
	// encoded as fixed32 length delimited
	optional TransportRoutes routes = 3; // routes 

	// encoded as fixed32 length delimited
	optional TransportStopsTree stops = 6;
	
	
	required StringTable stringTable = 9;
}

message OsmAndPoiIndex {
    required string name = 1;
    
    required OsmAndTileBox boundaries = 2;
    
    repeated OsmAndCategoryTable categoriesTable = 3;
    
    // encoded as fixed32 length delimited
    optional OsmAndPoiNameIndex nameIndex = 4;
    
	// encoded as fixed32 length delimited
	repeated OsmAndPoiBox boxes = 6; // children 

	// encoded as fixed32 length delimited
	repeated OsmAndPoiBoxData poiData = 9;
	
}

message OsmAndPoiNameIndex {
   // shift to OsmAndPoiNameIndexData starting from OsmAndPoiIndex message
   // encoded as fixed32 length delimited
   required IndexedStringTable table = 3;

   repeated OsmAndPoiNameIndexData data = 5;
   message OsmAndPoiNameIndexData {
   		// can contain multiple data offsets
   		repeated OsmAndPoiNameIndexDataAtom atoms = 3;
   }
}

message OsmAndPoiNameIndexDataAtom {
   // fields do not preserve order define, they are repeating 
   optional uint32 zoom = 2;
   optional uint32 x = 3;
   optional uint32 y = 4;
   // shift to OsmAndPoiBoxData message from OsmAndPoiNameIndexDataAtom.start
   // message is started when body is started
   optional fixed32 shiftTo = 14;
}


message OsmAndCategoryTable {
    required string category = 1;
    repeated string subcategories = 3;
}

message OsmAndPoiBox {
   required uint32 zoom = 1; // delta encoded to parent
   // size is one tile
   required sint32 left = 2; // delta encoded (zoom)
   required sint32 top = 3; // delta encoded (zoom)
   
   optional OsmAndPoiCategories categories = 4;
    
   // encoded as fixed32 length delimited
   repeated OsmAndPoiBox subBoxes = 10;
   
   // must be the last
   optional fixed32 shiftToData = 14; // shift to OsmAndPoiBoxData message from OsmAndPoiIndex.start
                                      // message is started when body is started
}

message OsmAndPoiCategories {
   // sorted categories
   repeated uint32 categories = 3;
}

message OsmAndPoiBoxData {
  optional uint32 zoom = 1; // zoom level
  optional uint32 x = 2; // x tile
  optional uint32 y = 3; // y tile
  
  repeated OsmAndPoiBoxDataAtom poiData = 5;
}

message OsmAndPoiBoxDataAtom {
  required sint32 dx = 2; // delta encoded to OsmAndPoiBox on 24 zoom
  required sint32 dy = 3; // delta encoded to OsmAndPoiBox on 24 zoom

  repeated uint32 categories = 4;

  optional string name = 6;
  optional string nameEn = 7;
  optional uint64 id = 8;  
  
  optional string openingHours = 10;
  optional string site = 11;
  optional string phone = 12;
  optional string note = 13;
}

/**
 * Id table 1-based. Map of sequential ids to real ids
 * [1,2,3....n] -> [a1, ... an]
 * a1,.. an - (ideally sorted) set of longs
 */
message IdTable {
   // diff between 2 ids
   repeated sint64 routeId = 1;
}

message RestrictionData {
	required int32 type = 1;
	required int32 from = 2;
	required int32 to = 3;
	optional int32 via = 4;
}


message RouteData {
	// array of delta x,y sint32 (CodedIinputStream) >> 5
	// first x delta to Tree.left, y to delta Tree.top (next delta to previous)
  	required bytes points = 1;

  	// continuous array of pairs
  	//  [pointIndex - int32, pointTypes - bytes]
  	// bytes - array of raw var int types
	optional bytes pointTypes = 4;

	// array of raw var int types
  	required bytes types = 7;

  	required int32 routeId = 12; // id internal

    // repeated array<pair<tagId : raw_var_int, indexOfStringInParent : raw_var_int> >
  	optional bytes stringNames = 14; // in parent block

}

message OsmAndRoutingIndex {
	required string name = 1;
	repeated RouteEncodingRule rules = 2;
	message RouteEncodingRule {
		required string tag = 3;
		required string value = 5;
		// it is optional because natural order in block of rules
		// is the same as id (id is 1-based and order)
		optional uint32 id = 7;
	}

	// encoded as fixed32 length delimited
	repeated RouteDataBox rootBoxes = 3;

	repeated RouteDataBlock blocks = 5;
	message RouteDataBox {
		// for root box is absolute coordinates
		required sint32 left = 1; // delta encoded
		required sint32 right = 2; // delta encoded
		required sint32 top = 3; // delta encoded
		required sint32 bottom = 4; // delta encoded

		//shift from routeDataBox start to message RouteDataBlock
		optional fixed32 shiftToData = 5;
		repeated RouteDataBox boxes = 7;
	}

	message RouteDataBlock {
	// coordinates can take much space 4*4*count of data blocks=
	//   required sint32 left = 1; // delta encoded
	//   required sint32 right = 2; // delta encoded
	//   required sint32 top = 3; // delta encoded
	//   required sint32 bottom = 4; // delta encoded
		optional IdTable idTable = 5;
		optional StringTable stringTable = 8;
		repeated RouteData dataObjects = 6;
		repeated RestrictionData restrictions = 7;

	}

}